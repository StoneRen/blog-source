---
title: js中利用矩阵思想来进行压缩编码
date: 2017-08-06 13:25:27
tags: [matrix,矩阵,js,compress,code,压缩]
---


## 需求

要生成一个`码A`,共12位,只能包含字符和数字.其中要包括`要素A`,8位十进制数字(id),未来肯定会增大.`要素B`,9位十进制数字(id),以后也肯定会增大.


要想在12位的字符`码A`中,包含两个要素.如果直接把他们的id添加进来,肯定超出了`码A`的承载(8+9>12).所以我想到了对`要素A`和`要素B`进行压缩.

**题外话**:为啥你的需求总是那么难以捉摸?你要知道基本上所有都是我一个人在整理需求和开发整个技术(前端后端运维)的时,关键还有第三方数据的牵扯,你是不是能稍微理解点了.

![理解](http://s1.jiasucloud.com/blog/image/9150e4e5gw1fatxdztsvqj206o06odge.jpg-s?jpg)

## 分析

<!--more-->

先想到压缩2位或者压缩3位,压缩后的个数需要固定位数.举例如下:

如: `要素A`为`12345678` `要素B`为`123456789`

`两两压缩`
`要素A`变为 [12,34,56,78],只要用一个符号(可以是数字或者字符,可能是单个也可能是组合)2位数的话,那么这个`要素A`就变成了4位.

`三三压缩`,
同理,`要素A`变为[123,456,78],压缩后就只有3位了

那么接下来就需要找一个固定位数来表示上面压缩后的字符了.
比如 `12 => a` 表示用`a`表示压缩前的`12`.但是明显单字符`0-9,a-z,A-Z`合起来也就是62个字符,如果碰到 `88`这个数字怎么表示呢.其实单字符表示并不是真正的压缩,只是进行了一下转义,类似于进制.就像这个例子.我们可以自己写一个`62进制`当然也能表示任何数字.但`进制表示`是行不通的.

## 整理后的需求

为什么进制表示行不通呢?问题就是我们的`码A`承载是有限的,不是可以无限扩展的.如果每个压缩后的位数无法固定长度,很容易就混乱了.比如编码手`AEw2wd1DEwED`,我们是无法区分到底应该从哪个字符对他们进行区分.因为不知道他们用我们的进制表示是几.比如4的二进制表示是`100`,而`9`的二进制表示`1001`,有一个`1001001`我们不知道是分为`100 1001`还是`1001 001`了.所以进制表示会有这样的问题,导致方案不可行.

所以现在的需求就变成了:

1. 在有限位数内,表示尽可能多的数字.
2. 位数是固定的 (当然这个可以优化,看下面的`优化`章节)
3. 需要`要素A`和`要素B`的扩展性,比如某一天`要素B`突然由9位数变到10位数,也需要能正确表示

现在手里的资源是我们能组合`62个字符`,要尽可能多的表示出`17位数字`.我想到的就是矩阵相乘.(题外话:矩阵最神奇之处的`A*B!=B*A`的特性是我一直觉着数学最有意思的地方.)

想想一下矩阵A为`1*62`矩阵,矩阵B为`62*1`矩阵,他们相乘(当然我们用的计算方式是字符相加),我们获取到`3844`个固定长度的字符,也就是能表示的最大数字就是`3844`.每个压缩后的字符为2位.

再返回头去,看如何分割.
如果是`三三分割`变为[123,456,789],相对比`3844`能表示的数字有点浪费.不仅如此[123,456,78]需要用6个字符表示,[123,456,789]业务要用6位字符表示,已经完全撑满了.如果`要素B`数字增长到10位数字那整个程序就出错误了,因为表示不下第十个数字了.
如果是`四四分割`变为[1234,5678,9],又无法固定位表示其中数字,比如`5678`就无法通过`3844`中的某个字符表示出来.


似乎我们又陷入到了一个困境中.但其实很简单,再乘62就可以了,最终结果变成了`238328`.现在每个压缩后的字符变为3位数.比如第一位为`000`,最后一个应该是`9zz`.
既然能表示的最大数字为`238328`,那么我们就完全可以表示5位数字,这个最大数字就是`99999`.   
如下:
`要素A`[12345,678]用6位字符表示,因为每一段数字用3个字符表示,形式为`xxxyyy`
`要素B`[12345,6789]也可以用6位数字表示了,因为也只划分了2段,每段3个字符,形式同样为`xxxyyy`

如果上面再扩展,现在看到就是`要素A`还能扩大100倍规模,`要素B`还能扩大10倍到1亿规模.这个就现在是一个可行的方案.

## 优化

那么是否还有优化的地方吗?我们怎么能够再优化呢?

### 优化1:非固定位数
之前一直讨论的是固定字符数表示数字,好处显而易见,但是确实浪费了近一半的字符.如果非固定字符,大概过程计算如下:
`12345678` => [`123456`,`78`] 用6位字符表示
`23832834` => [`238327`,`34`] 因为`238328`这个数字是能用已有字符表示
`23832934` => [`23832`,`834`] 因为`238329`这个数字表示不了,只能保留前面的最大数字,由`6位分割`变为`5位分割`,`8`自动分割到下一批,组成了`834`
也就是说用6位字符表示的最大数字为`238328238328`已经能表示`2万亿`个数字了.这个要远远比上面那个死板的固定位数分割表示强劲的多.字符没增多,突然能表示的数字变的这么多,多神奇啊!!!😯   
![好神奇啊](http://s1.jiasucloud.com/blog/image/shenqi.jpg-s)

这个和我们上面说的`需求`中的2`固定位数`冲突吗?
猛一想冲突了,但其实没有冲突.因为我们还是用2个3字符表示一个数字,也就是说最终一个数字还是靠6个字符表示,没有改变`固定位数`,只是修改了`切割方法`.虽然有点绕,但可以仔细想一想.

所以这个方案也是可以接受的,只是编码的时候稍微复杂一点,需要查询能表示的最大值.但是这个已经比上面的方案优化了很多

### 优化2:那就再增加一个字符吧

上面的数字`238328`很别扭,能切割的最大数字是`99999`,浪费近一半的字符,那我们从另一个思路出发,也就是浪费最少的生成字符.
所以我们在增加一个标识符只要乘以5就可以了,结果是`1191640`.(至于为啥乘以5,这个自己想吧)这样我们能表示的最大数字就是`999999`,浪费率为`16%`,比上面的浪费率`(238328-99999)/238328=58%`好了太多太多了.

也就是说我们现在用4个字符表示一个数字了.

这样的计算方式变为:

1. `12345678` => [`123456`,`78`] 需要`4+4=8`个字符表示
2. `92345678` => [`923456`,`78`] 需要`4+4=8`个字符表示
3. `999999999` => [`999999`,`999`] 需要`4+4=8`个字符表示

这种方式虽然能表示的数字更大了,但是却没有减少字符,已经超出了我们`码A`的最大承载(8+8>16).因为帮其他人拓宽以下思路,所以在此页写出来了.

当然这样做的坏处有2个:
1. 虽然浪费率低,但是整体字符的压缩效率不高.之前分割数字每段用3位字符表示,现在却要用4位字符表示.看`1`中的情形,原来的8位数数字,结果还是用8位字符表示的.也就是说对应现在情况,压缩率变低了.
2. 解码的时候 查询效率肯定更慢.这个一开始是理论上的担心.但实际测试后,完全可以忽略,具体可以查看这里,在自己浏览器里测试一下吧   

[JS Bin demo](http://output.jsbin.com/mogodol) 
[github gist](https://gist.github.com/StoneRen/2bfb0348f877ff06a1521681c51fe02f)

**2017-08-07更新:** 这个地方看`意外`这个章节

在我mac下chrome浏览器的测试结果如下:
![3](http://s1.jiasucloud.com/blog/image/WX20170804-155846.png-s?png)
![3-2](http://s1.jiasucloud.com/blog/image/WX20170804-155908.png-s?png)
![4](http://s1.jiasucloud.com/blog/image/WX20170804-155951.png-s?png)
![5](http://s1.jiasucloud.com/blog/image/WX20170804-160106.png-s?png)

4位数字也在几毫秒内
5位字符能表示`1191640`个数字,查询最后一个数字,耗时为`11ms`,这个结果足够可以了

## 优化3: 精确控制浪费率

其实就是在上面的思路上,精准控制生成的字符,比如我要生成一个能表示最大数字为`99999`的字符.那么可以计算 `50*50*40`就可以了.这样字符也都没超过62,自己构造3个数组进行拼凑字符就可以了.[JS Bin demo](http://output.jsbin.com/mogodol) 中的`cover`变量其实就是补位字符.

## 提示

当然,这些字符其实相应的也是你自己的密码盘,你可以通过修改顺序,比如随机打乱数字做一个自己的密码盘,这样别人也就不会轻易解码你的编码后的字符了.比如我上面`jsBin`的例子中,其实就是打乱顺讯的.

另外还涉及到编码和解码.如果有时间,会在下一篇文章中整理处理.本篇只是针对数字压缩进行了讨论.

## 意外

 在[JS Bin demo](http://output.jsbin.com/mogodol) 本身编辑的时候,是可以生成5位字符的编码的.但是我自己在写nodejs程序的时候,一直报内存错误.所以从这里隐约透露出`jsbin`的解释器和浏览器是否不同?
 ![chrome cry](http://s1.jiasucloud.com/blog/image/chrome-cry.png-s)
 并且各位也不在再在浏览器中试验生成5位数的压缩方式了,因为同样会报内存溢出.导致浏览器崩溃
 我们在计算一下 `62*62*62*62*62=916132832`9亿多长度的一个数组,在js里是不存在的吧.


